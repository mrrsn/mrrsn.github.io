import{playBeep}from"../audio/beep.js";import{pollDetector}from"../audio/detector.js";import{formatTime}from"./utils.js";import{getTotalSeconds,getCalibrationOffset,setCalibrationOffset,getBeepOnShot}from"./config.js";import{getAudioContext}from"../audio/context.js";import{addShotRow,clearShotsTable}from"../ui/shotsTable.js";let rafId=null,startTime=0,totalDuration=0,shotLog=[],participantShots=[],timerFinished=!1,acceptShots=!1;const _attempts={};let _currentStageKey=null,_currentCourseCredits=null;function _makeKey(t,e){return`${t||""}:${null!=e?String(e):""}`}export function setStageContext({courseId:t="",courseName:e="",stageId:o=null,courseCredits:n=null}={}){_currentStageKey=_makeKey(t,o),_currentCourseCredits=Array.isArray(n)?n:null,_attempts[_currentStageKey]||(_attempts[_currentStageKey]=1)}export function incrementStageAttempt(){return _currentStageKey?(_attempts[_currentStageKey]=(_attempts[_currentStageKey]||1)+1,_attempts[_currentStageKey]):1}export function getStageAttemptLabel({courseId:t="",stageId:e=null}={}){const o=t||null!=e?_makeKey(t,e):_currentStageKey;if(!o)return null!=e?String(e):"";const n=o.split(":")[1]||"",a=_attempts[o]||1;if(!n)return"";if(a<=1)return n;return`${n}${String.fromCharCode("a".charCodeAt(0)+(a-2))}`}function updateDisplay(t){const e=document.getElementById("display");e&&(e.textContent=formatTime(Math.max(0,t)))}function csvSafeField(t){if(null==t)return"";const e=String(t);return`"${(/^[=+\-@]/.test(e)?`'${e}`:e).replace(/"/g,'""')}"`}export function startTimer(t={}){totalDuration=1e3*getTotalSeconds(),startTime=performance.now(),shotLog=[],acceptShots=!0,timerFinished=!1,clearShotsTable(),updateDisplay(totalDuration),t.skipInitialBeep||playBeep(),rafId=requestAnimationFrame(tick);try{document.dispatchEvent(new CustomEvent("stageStarted",{detail:{when:performance.now()}}))}catch(t){}}export function handleShot(t,e=null){if(!startTime)return;if(!acceptShots)return void console.debug("handleShot: shot ignored because acceptShots is false");const o=getCalibrationOffset?getCalibrationOffset():0,n=Math.max(0,t-(o||0)),a=n-startTime,r=shotLog.length,s=shotLog.length>0?shotLog[shotLog.length-1]:null,i=s?n-s.ts:a;shotLog.push({idx:r,ts:n,rawTs:t,elapsed:a,rms:e,delta:i}),console.debug("handleShot: recorded shot",{shotIdx:r,adjustedTs:n,timestampMs:t,elapsed:a,rms:e,delta:i}),addShotRow(r,i,a,n,e),getBeepOnShot&&getBeepOnShot()&&playBeep()}export function archiveStageShots({courseId:t="",courseName:e="",stageId:o=null}={}){if(!shotLog||0===shotLog.length)return 0;participantShots.length;for(const n of shotLog)participantShots.push(Object.assign({},n,{participantIdx:participantShots.length,courseId:t,courseName:e,stageId:o,courseCredits:_currentCourseCredits?JSON.parse(JSON.stringify(_currentCourseCredits)):null}));const n=shotLog.length;return console.debug(`archiveStageShots: archived ${n} shots (stage ${o})`),n}function tick(t){const e=totalDuration-(t-startTime);if(updateDisplay(Math.max(0,e)),pollDetector(t),e<=0){if(!timerFinished){playBeep(),timerFinished=!0;try{document.dispatchEvent(new CustomEvent("stageFinished",{detail:{when:performance.now()}}))}catch(t){console.warn("Could not dispatch stageFinished event",t)}}rafId=requestAnimationFrame(tick)}else rafId=requestAnimationFrame(tick)}export function resetTimer(){rafId&&(cancelAnimationFrame(rafId),rafId=null),startTime=0,timerFinished=!1,totalDuration=0,shotLog=[],clearShotsTable(),updateDisplay(0),acceptShots=!1}export function stopTimer(){rafId&&(cancelAnimationFrame(rafId),rafId=null),acceptShots=!1;try{document.dispatchEvent(new CustomEvent("timerStopped",{detail:{when:performance.now()}}))}catch(t){}}export function calibrateLatency(){(async()=>{const t=[];let e;const o=[];const{setShotCallback:n}=await import("../audio/detector.js"),a=n(function(t){o.push(t),e&&e(t)});performance.now();for(let o=0;o<5;o++){const n=performance.now();playBeep();const a=new Promise(t=>{e=t});let r=null;try{r=await Promise.race([a,new Promise(t=>setTimeout(()=>t(null),2e3))])}catch(t){r=null}if(e=null,r){const e=r-n;t.push(e),console.log("calibration: sample",o,"latencyMs=",e),await new Promise(t=>setTimeout(t,250))}else console.warn("calibration: no detection for sample",o)}try{n(a)}catch(t){console.warn("calibrate: could not restore shot callback",t)}if(0===t.length){console.warn("calibration: no acoustic detections; attempting internal loopback fallback");const t=getAudioContext();if(!t)return void alert("Calibration failed: no detections and no AudioContext available. Ensure microphone permission and try again.");const e=(t,e,o=1e3)=>new Promise(n=>{const a=performance.now();let r=null;r=requestAnimationFrame(function s(){try{t.getByteTimeDomainData(e)}catch(t){return void n(null)}let i=0;for(let t=0;t<e.length;t++){const o=e[t]-128;i+=o*o}Math.sqrt(i/e.length)>5?n(performance.now()):performance.now()-a>o?n(null):r=requestAnimationFrame(s)})}),o=[],n=5;for(let a=0;a<n;a++){const n=t.createOscillator(),r=t.createGain(),s=t.createAnalyser();s.fftSize=256;const i=new Uint8Array(s.frequencyBinCount||128);n.frequency.value=1200,r.gain.setValueAtTime(.5,t.currentTime),r.gain.exponentialRampToValueAtTime(.001,t.currentTime+.12),n.connect(r).connect(s).connect(t.destination);const c=performance.now();n.start(),n.stop(t.currentTime+.12);const l=await e(s,i,800);l?(o.push(l-c),console.log("calibration(loopback): sample",a,"latencyMs=",l-c)):console.warn("calibration(loopback): no internal detection for sample",a),await new Promise(t=>setTimeout(t,150))}if(0===o.length)return void alert("Calibration failed: no detections (acoustic or internal). Check microphone and speaker routing.");o.sort((t,e)=>t-e);const a=Math.floor(o.length/2),r=o.length%2==1?o[a]:(o[a-1]+o[a])/2;return setCalibrationOffset(Math.round(r)),console.log("calibration(loopback): median latency ms =",r),void alert(`Calibration (internal loopback) complete — median latency ${Math.round(r)} ms recorded. Note: this measures internal audio graph latency, not acoustic microphone pickup.`)}t.sort((t,e)=>t-e);const r=Math.floor(t.length/2),s=t.length%2==1?t[r]:(t[r-1]+t[r])/2;setCalibrationOffset(Math.round(s)),console.log("calibration: median latency ms =",s),alert(`Calibration complete — median latency ${Math.round(s)} ms recorded.`)})()}export function getShotLog(){return shotLog.slice()}export function exportShotsCsv(){const t=[];t.push(["idx","elapsed_ms","delta_ms","raw_ts","calibrated_ts","rms"].join(","));const e=getShotLog();for(const o of e){const e=o.idx,n="number"==typeof o.elapsed?o.elapsed.toFixed(3):"",a="number"==typeof o.delta?o.delta.toFixed(3):"",r="number"==typeof o.rawTs?o.rawTs.toFixed(3):"",s="number"==typeof o.ts?o.ts.toFixed(3):"",i="number"==typeof o.rms?o.rms.toFixed(4):"";t.push([csvSafeField(e),csvSafeField(n),csvSafeField(a),csvSafeField(r),csvSafeField(s),csvSafeField(i)].join(","))}return _currentCourseCredits&&Array.isArray(_currentCourseCredits)&&_currentCourseCredits.length>0&&(t.push(""),t.push(["credits",csvSafeField(JSON.stringify(_currentCourseCredits))].join(","))),t.join("\n")}export function exportParticipantCsv(){const t=[];t.push(["pidx","courseId","courseName","stageId","elapsed_ms","delta_ms","raw_ts","calibrated_ts","rms","courseCredits"].join(","));for(const e of participantShots){const o=null!=e.participantIdx?e.participantIdx:"",n=e.courseId||"",a=e.courseName||"",r=null!=e.stageId?e.stageId:"",s="number"==typeof e.elapsed?e.elapsed.toFixed(3):"",i="number"==typeof e.delta?e.delta.toFixed(3):"",c="number"==typeof e.rawTs?e.rawTs.toFixed(3):"",l="number"==typeof e.ts?e.ts.toFixed(3):"",u="number"==typeof e.rms?e.rms.toFixed(4):"",d=e.courseCredits?JSON.stringify(e.courseCredits):"";t.push([csvSafeField(o),csvSafeField(n),csvSafeField(a),csvSafeField(r),csvSafeField(s),csvSafeField(i),csvSafeField(c),csvSafeField(l),csvSafeField(u),csvSafeField(d)].join(","))}return t.join("\n")}export function clearParticipantShots(){participantShots=[],console.debug("clearParticipantShots: participant shot store cleared")}